"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const object_hash_1 = __importDefault(require("object-hash"));
const config_1 = __importDefault(require("./config"));
const bull_1 = __importDefault(require("bull"));
const common_1 = require("./common");
const store_1 = require("./store");
// command-line params
const parentId = process.argv[2];
const platformName = process.argv[3];
let identifier = process.argv[4];
const loggerPrefix = `sockethub:platform:${platformName}:${identifier}`;
let logger = (0, debug_1.default)(loggerPrefix);
const PlatformModule = require(`sockethub-platform-${platformName}`);
let queueStarted = false;
let parentSecret1, parentSecret2;
logger(`platform handler initialized for ${platformName} ${identifier}`);
/**
 * Handle any uncaught errors from the platform by alerting the worker and shutting down.
 */
process.on('uncaughtException', (err) => {
    console.log('UNCAUGHT EXCEPTION IN PLATFORM');
    // eslint-disable-next-line security-node/detect-crlf
    console.log(err.stack);
    process.send(['error', err.toString()]);
    process.exit(1);
});
/**
 * Incoming messages from the worker to this platform. Data is an array, the first property is the
 * method to call, the rest are params.
 */
process.on('message', (data) => {
    if (data[0] === 'secrets') {
        parentSecret1 = data[1].parentSecret1;
        parentSecret2 = data[1].parentSecret2;
        startQueueListener();
    }
});
/**
 * Initialize platform module
 */
const platformSession = {
    debug: (0, debug_1.default)(`sockethub:platform:${platformName}:${identifier}`),
    sendToClient: getSendFunction('message'),
    updateActor: updateActor
};
const platform = new PlatformModule(platformSession);
/**
 * Get the credentials stored for this user in this sessions store, if given the correct
 * sessionSecret.
 * @param actorId
 * @param sessionId
 * @param sessionSecret
 * @param cb
 */
function getCredentials(actorId, sessionId, sessionSecret, cb) {
    if (platform.config.noCredentials) {
        return cb();
    }
    const store = (0, store_1.getSessionStore)(parentId, parentSecret1, sessionId, sessionSecret);
    store.get(actorId, (err, credentials) => {
        if (platform.config.persist) {
            // don't continue if we don't get credentials
            if (err) {
                return cb(err);
            }
        }
        else if (!credentials) {
            // also skip if this is a non-persist platform with no credentials
            return cb();
        }
        if (platform.credentialsHash) {
            if (platform.credentialsHash !== (0, object_hash_1.default)(credentials.object)) {
                return cb('provided credentials do not match existing platform instance for actor '
                    + platform.actor['@id']);
            }
        }
        else {
            platform.credentialsHash = (0, object_hash_1.default)(credentials.object);
        }
        cb(undefined, credentials);
    });
}
/**
 * Returns a function used to handle completed jobs from the platform code (the `done` callback).
 * @param secret the secret used to decrypt credentials
 */
function getJobHandler(secret) {
    return (job, done) => {
        const jobData = (0, common_1.decryptJobData)(job, secret);
        const jobLog = (0, debug_1.default)(`${loggerPrefix}:${jobData.sessionId}`);
        jobLog(`job ${jobData.title}: ${jobData.msg['@type']}`);
        const sessionSecret = jobData.msg.sessionSecret;
        delete jobData.msg.sessionSecret;
        return getCredentials(jobData.msg.actor['@id'], jobData.sessionId, sessionSecret, (err, credentials) => {
            if (err) {
                return done(new Error(err));
            }
            let jobCallbackCalled = false;
            const doneCallback = (err, result) => {
                if (jobCallbackCalled) {
                    return;
                }
                jobCallbackCalled = true;
                if (err) {
                    done(err instanceof Error ? err : new Error(err));
                }
                else {
                    done(null, result);
                }
            };
            if ((Array.isArray(platform.config.requireCredentials)) &&
                (platform.config.requireCredentials.includes(jobData.msg['@type']))) {
                // add the credentials object if this method requires it
                platform[jobData.msg['@type']](jobData.msg, credentials, doneCallback);
            }
            else {
                platform[jobData.msg['@type']](jobData.msg, doneCallback);
            }
        });
    };
}
/**
 * Get an function which sends a message to the parent thread (PlatformInstance). The platform
 * can call that function to send messages back to the client.
 * @param command string containing the type of command to be sent. 'message' or 'close'
 */
function getSendFunction(command) {
    return function (msg, special) {
        process.send([command, msg, special]);
    };
}
/**
 * When a user changes it's actor name, the channel identifier changes, we need to ensure that
 * both the queue thread (listening on the channel for jobs) and the logging object are updated.
 * @param credentials
 */
function updateActor(credentials) {
    identifier = (0, common_1.getPlatformId)(platformName, credentials.actor['@id']);
    logger(`platform actor updated to ${credentials.actor['@id']} identifier ${identifier}`);
    logger = (0, debug_1.default)(`sockethub:platform:${identifier}`);
    platform.credentialsHash = (0, object_hash_1.default)(credentials.object);
    platform.debug = (0, debug_1.default)(`sockethub:platform:${platformName}:${identifier}`);
    process.send(['updateActor', undefined, identifier]);
    startQueueListener(true);
}
/**
 * starts listening on the queue for incoming jobs
 * @param refresh boolean if the param is true, we re-init the queue.process
 * (used when identifier changes)
 */
function startQueueListener(refresh = false) {
    const secret = parentSecret1 + parentSecret2;
    if ((queueStarted) && (!refresh)) {
        logger('start queue called multiple times, skipping');
        return;
    }
    const queue = new bull_1.default(parentId + identifier, { redis: config_1.default.get('redis') });
    queueStarted = true;
    logger('listening on the queue for incoming jobs');
    queue.process(getJobHandler(secret));
}
//# sourceMappingURL=/platform.js.map