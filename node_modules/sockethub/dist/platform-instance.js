"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.platformInstances = void 0;
const child_process_1 = require("child_process");
const path_1 = require("path");
const debug_1 = require("debug");
const bull_1 = __importDefault(require("bull"));
const config_1 = __importDefault(require("./config"));
const serve_1 = require("./serve");
const common_1 = require("./common");
// collection of platform instances, stored by `id`
exports.platformInstances = new Map();
class PlatformInstance {
    constructor(params) {
        this.flaggedForTermination = false;
        this.sessions = new Set();
        this.global = false;
        this.sessionCallbacks = {
            'close': (() => new Map())(),
            'message': (() => new Map())(),
        };
        this.id = params.identifier;
        this.name = params.platform;
        this.parentId = params.parentId;
        if (params.actor) {
            this.actor = params.actor;
        }
        else {
            this.global = true;
        }
        this.debug = (0, debug_1.debug)(`sockethub:platform-instance:${this.id}`);
        // spin off a process
        this.process = (0, child_process_1.fork)((0, path_1.join)(__dirname, 'platform.js'), [this.parentId, this.name, this.id]);
    }
    /**
     * Destroys all references to this platform instance, internal listeners and controlled processes
     */
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            this.flaggedForTermination = true;
            exports.platformInstances.delete(this.id);
            try {
                yield this.queue.empty();
            }
            catch (e) { }
            try {
                yield this.queue.clean(0);
            }
            catch (e) { }
            try {
                yield this.queue.close();
            }
            catch (e) { }
            try {
                this.queue.removeAllListeners();
            }
            catch (e) { }
            try {
                yield this.queue.obliterate({ force: true });
            }
            catch (e) { }
            try {
                delete this.queue;
                this.process.removeAllListeners('close');
                this.process.unref();
                this.process.kill();
            }
            catch (e) { }
        });
    }
    /**
     * When jobs are completed or failed, we prepare the results and send them to the client socket
     */
    initQueue(secret) {
        this.queue = new bull_1.default(this.parentId + this.id, { redis: config_1.default.get('redis') });
        this.queue.on('global:completed', (jobId, resultString) => {
            const result = resultString ? JSON.parse(resultString) : "";
            this.queue.getJob(jobId).then((job) => __awaiter(this, void 0, void 0, function* () {
                yield this.handleJobResult('completed', (0, common_1.decryptJobData)(job, secret), result);
                job.remove();
            }));
        });
        this.queue.on('global:error', (jobId, result) => {
            this.debug("unknown queue error", jobId, result);
        });
        this.queue.on('global:failed', (jobId, result) => {
            this.queue.getJob(jobId).then((job) => __awaiter(this, void 0, void 0, function* () {
                yield this.handleJobResult('failed', (0, common_1.decryptJobData)(job, secret), result);
                job.remove();
            }));
        });
    }
    /**
     * Register listener to be called when the process emits a message.
     * @param sessionId ID of socket connection that will receive messages from platform emits
     */
    registerSession(sessionId) {
        if (!this.sessions.has(sessionId)) {
            this.sessions.add(sessionId);
            for (let type of Object.keys(this.sessionCallbacks)) {
                const cb = this.callbackFunction(type, sessionId);
                this.process.on(type, cb);
                this.sessionCallbacks[type].set(sessionId, cb);
            }
        }
    }
    /**
     * Sends a message to client (user), can be registered with an event emitted from the platform
     * process.
     * @param sessionId ID of the socket connection to send the message to
     * @param type type of message to emit. 'message', 'completed', 'failed'
     * @param msg ActivityStream object to send to client
     */
    sendToClient(sessionId, type, msg) {
        (0, serve_1.getSocket)(sessionId).then((socket) => {
            try {
                // this property should never be exposed externally
                delete msg.sessionSecret;
            }
            catch (e) { }
            msg.context = this.name;
            if ((msg['@type'] === 'error') && (typeof msg.actor === 'undefined') && (this.actor)) {
                // ensure an actor is present if not otherwise defined
                msg.actor = this.actor;
            }
            socket.emit(type, msg);
        }, (err) => this.debug(`sendToClient ${err}`));
    }
    // send message to every connected socket associated with this platform instance.
    broadcastToSharedPeers(sessionId, msg) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let sid of this.sessions.values()) {
                if (sid !== sessionId) {
                    this.debug(`broadcasting message to ${sid}`);
                    yield this.sendToClient(sid, 'message', msg);
                }
            }
        });
    }
    // handle job results coming in on the queue from platform instances
    handleJobResult(type, jobData, result) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug(`job ${jobData.title}: ${type}`);
            if ((type === 'completed') && (result)) {
                jobData.msg.object = {
                    '@type': 'result',
                    content: result
                };
            }
            else if (type === 'failed') {
                jobData.msg.object = {
                    '@type': 'error',
                    content: result ? result : "job failed for unknown reason"
                };
            }
            // send message to client as completed for failed job
            yield this.sendToClient(jobData.sessionId, type, jobData.msg);
            // let all related peers know of result as an independent message
            // (not as part of a job completion, or failure)
            yield this.broadcastToSharedPeers(jobData.sessionId, jobData.msg);
        });
    }
    /**
     * Sends error message to client and clears all references to this class.
     * @param sessionId
     * @param errorMessage
     */
    reportError(sessionId, errorMessage) {
        const errorObject = {
            context: this.name,
            '@type': 'error',
            actor: this.actor,
            object: {
                '@type': 'error',
                content: errorMessage
            }
        };
        this.sendToClient(sessionId, 'message', errorObject);
        this.sessions.clear();
        this.destroy();
    }
    /**
     * Updates the instance with a new identifier, updating the platformInstances mapping as well.
     * @param identifier
     */
    updateIdentifier(identifier) {
        exports.platformInstances.delete(this.id);
        this.id = identifier;
        exports.platformInstances.set(this.id, this);
    }
    /**
     * Generates a function tied to a given client session (socket connection), the generated
     * function will be called for each session ID registered, for every platform emit.
     * @param listener
     * @param sessionId
     */
    callbackFunction(listener, sessionId) {
        const funcs = {
            'close': (e) => {
                this.debug(`close even triggered ${this.id}: ${e}`);
                this.reportError(sessionId, `Error: session thread closed unexpectedly: ${e}`);
            },
            'message': (data) => {
                if (data[0] === 'updateActor') {
                    // We need to update the key to the store in order to find it in the future.
                    this.updateIdentifier(data[2]);
                }
                else if (data[0] === 'error') {
                    this.reportError(sessionId, data[1]);
                }
                else {
                    // treat like a message to clients
                    this.sendToClient(sessionId, 'message', data[1]);
                }
            }
        };
        return funcs[listener];
    }
}
exports.default = PlatformInstance;
//# sourceMappingURL=/platform-instance.js.map