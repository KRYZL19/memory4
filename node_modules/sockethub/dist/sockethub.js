"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const crypto_1 = __importDefault(require("./crypto"));
const init_1 = __importDefault(require("./bootstrap/init"));
const middleware_1 = __importDefault(require("./middleware"));
const create_activity_object_1 = __importDefault(require("./middleware/create-activity-object"));
const store_credentials_1 = __importDefault(require("./middleware/store-credentials"));
const validate_1 = __importDefault(require("./middleware/validate"));
const janitor_1 = __importDefault(require("./janitor"));
const serve_1 = __importDefault(require("./serve"));
const process_manager_1 = __importDefault(require("./process-manager"));
const platform_instance_1 = require("./platform-instance");
const store_1 = require("./store");
const log = (0, debug_1.default)('sockethub:core');
function errorHandler(type, socket, log) {
    return function reportError(err, msg) {
        log('failure handling ' + type + '. ' + err);
        if (typeof msg !== 'object') {
            msg = { context: 'error' };
        }
        msg.error = err;
        socket.emit('failure', msg);
    };
}
class Sockethub {
    constructor() {
        this.counter = 0;
        this.platforms = init_1.default.platforms;
        this.status = false;
        this.parentId = crypto_1.default.randToken(16);
        this.parentSecret1 = crypto_1.default.randToken(16);
        this.parentSecret2 = crypto_1.default.randToken(16);
        this.processManager = new process_manager_1.default(this.parentId, this.parentSecret1, this.parentSecret2);
        log('sockethub session id: ' + this.parentId);
    }
    /**
     * initialization of sockethub starts here
     */
    boot() {
        if (this.status) {
            return log('Sockethub.boot() called more than once');
        }
        else {
            this.status = true;
        }
        log('active platforms: ', [...init_1.default.platforms.keys()]);
        janitor_1.default.clean(); // start cleanup cycle
        serve_1.default.start(); // start external services
        log('registering handlers');
        serve_1.default.io.on('connection', this.incomingConnection.bind(this));
    }
    removeAllPlatformInstances() {
        for (let platform of platform_instance_1.platformInstances.values()) {
            platform.destroy();
        }
    }
    handleIncomingMessage(socket, sessionLog) {
        return (msg, done) => {
            const platformInstance = this.processManager.get(msg.context, msg.actor['@id'], socket.id);
            const title = `${msg.context}-${(msg['@id']) ? msg['@id'] : this.counter++}`;
            sessionLog(`queued to channel ${platformInstance.id}`);
            const job = {
                title: title,
                sessionId: socket.id,
                msg: crypto_1.default.encrypt(msg, this.parentSecret1 + this.parentSecret2)
            };
            platformInstance.queue.add(job);
            done(job);
        };
    }
    ;
    incomingConnection(socket) {
        const sessionLog = (0, debug_1.default)('sockethub:core:' + socket.id), // session-specific debug messages
        sessionSecret = crypto_1.default.randToken(16), 
        // store instance is session-specific
        store = (0, store_1.getSessionStore)(this.parentId, this.parentSecret1, socket.id, sessionSecret);
        sessionLog(`socket.io connection`);
        socket.on('disconnect', () => {
            sessionLog('disconnect received from client.');
        });
        socket.on('credentials', (0, middleware_1.default)(errorHandler('credentials', socket, sessionLog))((0, validate_1.default)('credentials', socket.id), (0, store_credentials_1.default)(store, sessionLog)));
        socket.on('message', (0, middleware_1.default)(errorHandler('message', socket, sessionLog))((0, validate_1.default)('message', socket.id), (msg, done) => {
            // middleware which attaches the sessionSecret to the message. The platform thread
            // must find the credentials on their own using the given sessionSecret, which indicates
            // that this specific session (socket connection) has provided credentials.
            msg.sessionSecret = sessionSecret;
            done(msg);
        }, this.handleIncomingMessage(socket, sessionLog)));
        // when new activity objects are created on the client side, an event is
        // fired and we receive a copy on the server side.
        socket.on('activity-object', (0, middleware_1.default)(errorHandler('message', socket, sessionLog))((0, validate_1.default)('activity-object', socket.id), create_activity_object_1.default));
    }
}
exports.default = Sockethub;
//# sourceMappingURL=/sockethub.js.map